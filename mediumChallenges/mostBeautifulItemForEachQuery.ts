// First Try - Binary search method sorting items based on price primarily and beauty secondly,
// using binary search to get the most affordable item and it's best price of value,
// giving a wrong answer as price isn't related with beauty. (Wrong Answer - 14 / 35 testcases passed)
// function maximumBeauty(items: number[][], queries: number[]): number[] {
//   items.sort((a, b) => {
//     const priceDiff = a[0] - b[0];
//     if(priceDiff === 0)
//       return a[1] - b[1];
//     return priceDiff;
//   });

//   const ans: number[] = [];
//   for(const query of queries) {
//     let left = 0, right = items.length - 1, mostBeauty = 0;
//     while(left <= right) {
//       const mid = left + Math.floor((right - left) / 2);

//       if(items[mid][0] > query) {
//         right = mid - 1;
//         continue;
//       }

//       mostBeauty = Math.max(mostBeauty, items[mid][1]);
//       left = mid + 1;
//     }
//     ans.push(mostBeauty);
//   }

//   return ans;
// };

// First Approach - Sorting, Hashmapping and Binary Search method, sorting all items by their price, iterating
// over discovering the most beauty value for each price and querying into items using binary search finding
// the most affordable item to each query, consulting it on hashmap. (122ms - Beats 18.75%)
function maximumBeauty(items: number[][], queries: number[]): number[] {
  items.sort((a, b) => {
    const priceDiff = a[0] - b[0];
    if(priceDiff === 0)
      return a[1] - b[1];
    return priceDiff;
  });

  const mostBeauty: Map<number, number> = new Map();
  let biggestBeautyValue = 0;
  for(const item of items) {
    biggestBeautyValue = Math.max(biggestBeautyValue, item[1]);
    mostBeauty.set(item[0], biggestBeautyValue);
  }

  const ans: number[] = [];
  for(const query of queries) {
    let left = 0, right = items.length - 1, mostBeautyVal = 0;
    while(left <= right) {
      const mid = left + Math.floor((right - left) / 2);

      if(items[mid][0] > query) {
        right = mid - 1;
        continue;
      }

      mostBeautyVal = mostBeauty.get(items[mid][0])!;
      left = mid + 1;
    }
    ans.push(mostBeautyVal);
  }

  return ans;
};

// Second Approach - Sorting and remapping items to a minimum price and maximum beauty items map,
// generated by ascending sorted items. (https://leetcode.com/problems/most-beautiful-item-for-each-query/solutions/6035442/beats-100-00-for-loop-explained-with-example/?envType=daily-question&envId=2024-11-12)
function maximumBeauty(items: number[][], queries: number[]) {
  const maxI = Number.MAX_SAFE_INTEGER;
  let res = [[0, 0, maxI]];

  items.sort((a, b) => a[0] - b[0]);

  for(let item of items) {
    let price = item[0];
    let beauty = item[1];
    let lastBracket = res.at(-1)!;

    if(beauty > lastBracket[1]) {
      res[res.length - 1][2] = price;
      res.push([price, beauty, maxI]);
    }
  }

  let ans: number[] = []

  for(let x of queries) {
    for(let i = res.length - 1; i > -1; i--) {
      if(res[i][0] <= x) {
        ans.push(res[i][1]);
        break;
      }
    }
  }

  return ans
};

const case1 = maximumBeauty([[1,2],[3,2],[2,4],[5,6],[3,5]], [1,2,3,4,5,6]);
console.log('------');
const case2 = maximumBeauty([[1,2],[1,2],[1,3],[1,4]], [1]);
console.log('------');
const case3 = maximumBeauty([[10,1000]], [5]);
console.log('------');
const case4 = maximumBeauty([[193,732],[781,962],[864,954],[749,627],[136,746],[478,548],[640,908],[210,799],[567,715],[914,388],[487,853],[533,554],[247,919],[958,150],[193,523],[176,656],[395,469],[763,821],[542,946],[701,676]], [885,1445,1580,1309,205,1788,1214,1404,572,1170,989,265,153,151,1479,1180,875,276,1584]);

console.log(`case1: ${case1} // Should be: [2,4,5,5,6,6]`);
console.log(`case2: ${case2} // Should be: [4]`);
console.log(`case3: ${case3} // Should be: [0]`);
console.log(`case4: ${case4} // Should be: [962,962,962,962,746,962,962,962,946,962,962,919,746,746,962,962,962,919,962]`);